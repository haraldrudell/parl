/*
© 2022–present Harald Rudell <harald.rudell@gmail.com> (https://haraldrudell.github.io/haraldrudell/)
ISC License
*/

package panicdetector

import (
	"errors"
	"fmt"
	"runtime"
	"testing"

	"github.com/haraldrudell/parl/pruntime"
)

const (
	// value indicator for indices()
	panicYes = true
	// value indicator for indices()
	panicNo = false
)

func TestIndices(t *testing.T) {
	var testList = []struct {
		name           string
		stackGenerator func() (stack pruntime.Stack, panicLoc, stackLoc *pruntime.CodeLocation)
		isPanic        bool
	}{
		{"no panic", noPanic, panicNo},
		{"invoke panic()", invokePanic, panicYes},
		{"nil pointer dereference", nilPointerDereference, panicYes},
		{"bad slice", slicePanic, panicYes},
	}

	var stackAct pruntime.Stack
	var isPanicAct bool
	var stackIndexAct, panicIndexAct int
	var panicLocExp, stackLocExp *pruntime.CodeLocation
	for _, params := range testList {
		stackAct, panicLocExp, stackLocExp = params.stackGenerator()

		if params.isPanic {
			// INPUTSTACK for test: panic(1) stack:ID: 4 IsMain: false status: running
			//   github.com/haraldrudell/parl/perrors/errorglue.panicOneDefer(0x1, 0x1400006ce08)
			//     indices_test.go:99
			//   panic({0x102dcdba0?, 0x102eb3188?})
			//     panic.go:914
			//   github.com/haraldrudell/parl/perrors/errorglue.panicOne()
			//     indices_test.go:88
			//   github.com/haraldrudell/parl/perrors/errorglue.TestIndices(0x140000036c0)
			//     indices_test.go:43
			//   testing.tRunner(0x140000036c0, 0x102df5de8)
			//     testing.go:1595
			//   cre: testing.(*T).Run-testing.go:1648 in goroutine 1 1
			// INPUTSTACK for test: nil pointer dereference stack:ID: 4 IsMain: false status: running
			// github.com/haraldrudell/parl/perrors/errorglue.panicNilPointerDefer({0x102d95195, 0x40}, 0x14000123e00)
			// 	indices_test.go:134
			// panic({0x102dd5740?, 0x102ebb950?})
			// 	panic.go:914
			// github.com/haraldrudell/parl/perrors/errorglue.panicNilPointer()
			// 	indices_test.go:113
			// github.com/haraldrudell/parl/perrors/errorglue.TestIndices(0x140000036c0)
			// 	indices_test.go:43
			// testing.tRunner(0x140000036c0, 0x102df5de8)
			// 	testing.go:1595
			// cre: testing.(*T).Run-testing.go:1648 in goroutine 1 1
			t.Logf("INPUTSTACK for test: ‘%s’ stack:%s", params.name, stackAct)
		}

		isPanicAct, stackIndexAct, panicIndexAct = Indices(stackAct)

		// isPanic should match
		if isPanicAct != params.isPanic {
			t.Errorf("FAIL test ‘%s’ Indices() isPanic %t exp %t",
				params.name,
				isPanicAct, params.isPanic,
			)
			continue
		} else if !isPanicAct {
			continue
		} else if stackLocExp == nil || panicLocExp == nil {
			t.Fatalf("FAIL CORRUPTION test ‘%s’ recover nil %t panic nil %t",
				params.name,
				stackLocExp == nil,
				panicLocExp == nil,
			)
		}

		// recoveryIndex should match
		if actLine, expLine := stackAct.Frames()[stackIndexAct].Loc().FuncLine(), stackLocExp.FuncLine(); actLine != expLine {
			t.Errorf("FAIL test ‘%s’ Indices() recovery index: %d:\n%s\n%s",
				params.name, stackIndexAct,
				actLine, expLine,
			)
		}

		// panicIndex should match
		if actLine, expLine := stackAct.Frames()[panicIndexAct].Loc().FuncLine(), panicLocExp.FuncLine(); actLine != expLine {
			t.Errorf("FAIL test ‘%s’ Indices() panic index %d:\n%s\n%s",
				params.name, panicIndexAct,
				actLine, expLine,
			)
		}
	}
}

// noPanic returns a deferred stack trace generated without a panic
func noPanic() (stack pruntime.Stack, panicLoc, recoverLoc *pruntime.CodeLocation) {
	defer noPanicDefer(&stack)

	return
}

// noPanicDefer is defereed function for noPanic
func noPanicDefer(stackp *pruntime.Stack) {
	*stackp = pruntime.NewStack(0)
}

// invokePanic returns a deferred stack trace generated by panic(1)
func invokePanic() (stack pruntime.Stack, panicLoc, stackLoc *pruntime.CodeLocation) {
	var one = 1
	defer invokePanicDefer(one, &stack, &stackLoc)

	for panicLoc = pruntime.NewCodeLocation(0); ; panic(one) {
	}
}

// invokePanicDefer is defer function for panicOne
func invokePanicDefer(one int, stackp *pruntime.Stack, stackLoc **pruntime.CodeLocation) {
	var recoverValue = recover()
	if recoverValue != one {
		panic(fmt.Errorf("bad recover value: %T “%[1]v” exp: %d",
			recoverValue,
			one,
		))
	}
	var s, loc = pruntime.NewStack(0), pruntime.NewCodeLocation(0)
	*stackp = s
	*stackLoc = loc
}

// panicFunction recovers a panic using [parl.RecoverErr]
//   - panicLine is the exact code line of the panic
//   - err is the error value produced by [parl.RecoverErr]
func nilPointerDereference() (stack pruntime.Stack, panicLoc, stackLoc *pruntime.CodeLocation) {
	// runtime.errorString “runtime error: invalid memory address or nil pointer dereference”
	//	- runtime.errorString implements error
	//	- only methods are Error() and RuntimeError()
	var message = "runtime error: invalid memory address or nil pointer dereference"
	defer nilPointerDereferenceDefer(message, &stack, &stackLoc)

	// nil pointer dereference panic
	for panicLoc = pruntime.NewCodeLocation(0); ; _ = *(*int)(nil) {
	}
}

// nilPointerDereferenceDefer is defer function for panicNilPointer
func nilPointerDereferenceDefer(message string, stackp *pruntime.Stack, stackLoc **pruntime.CodeLocation) {
	var recoverValue = recover()
	var isOk bool
	if err, ok := recoverValue.(error); ok {
		var runtimeError runtime.Error
		if errors.As(err, &runtimeError) {
			isOk = err.Error() == message
		}
	}
	if !isOk {
		panic(fmt.Errorf("bad recover value: %T “%[1]v” exp err message: “%s”",
			recoverValue,
			message,
		))
	}
	var s, loc = pruntime.NewStack(0), pruntime.NewCodeLocation(0)
	*stackp = s
	*stackLoc = loc
}

// panicFunction recovers a panic using [parl.RecoverErr]
//   - panicLine is the exact code line of the panic
//   - err is the error value produced by [parl.RecoverErr]
func slicePanic() (stack pruntime.Stack, panicLoc, stackLoc *pruntime.CodeLocation) {
	// runtime.errorString “runtime error: invalid memory address or nil pointer dereference”
	//	- runtime.errorString implements error
	//	- only methods are Error() and RuntimeError()
	var message = "runtime error: index out of range [0] with length 0"
	defer slicePanicDefer(message, &stack, &stackLoc)

	// nil pointer dereference panic
	var slice = make([]byte, 0)
	for panicLoc = pruntime.NewCodeLocation(0); ; _ = slice[0] {
	}
}

// slicePanicDefer is defer function for slicePanic
func slicePanicDefer(message string, stackp *pruntime.Stack, stackLoc **pruntime.CodeLocation) {
	var recoverValue = recover()
	var isOk bool
	if err, ok := recoverValue.(error); ok {
		var runtimeError runtime.Error
		if errors.As(err, &runtimeError) {
			isOk = err.Error() == message
		}
	}
	if !isOk {
		panic(fmt.Errorf("bad recover value: %T “%[1]v” exp err message: “%s”",
			recoverValue,
			message,
		))
	}
	var s, loc = pruntime.NewStack(0), pruntime.NewCodeLocation(0)
	*stackp = s
	*stackLoc = loc
}
