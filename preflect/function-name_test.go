/*
© 2024–present Harald Rudell <harald.rudell@gmail.com> (https://haraldrudell.github.io/haraldrudell/)
ISC License
*/

package preflect

import (
	"errors"
	"os"
	"strings"
	"testing"

	"github.com/haraldrudell/parl"
	"github.com/haraldrudell/parl/perrors"
	"github.com/haraldrudell/parl/pruntime"
)

// funcName is a top-level func fixture
func funcName() {}

func TestFunctionName(t *testing.T) {
	//t.Error("logging on")
	var expFuncName = "funcName"
	var expAnonymous = "TestFunctionName.func"
	var expMethod = "Close-fm"

	var codeLocation *pruntime.CodeLocation
	var err error
	var anonymous = func() {}

	// top-level function should work
	codeLocation, err = FuncName(funcName)
	// FuncName(funcName top-level func) → cL: File: "/opt/sw/parl/preflect/function-name_test.go" Line: 18 FuncName: "github.com/haraldrudell/parl/preflect.funcName" err: “OK”
	t.Logf("FuncName(funcName top-level func) → cL: %s err: “%s”",
		codeLocation.Dump(), perrors.Short(err),
	)
	if err != nil {
		t.Errorf("FAIL FuncName top-level function err: %s", perrors.Short(err))
	}
	if codeLocation.FuncIdentifier() != expFuncName {
		t.Errorf("FAIL FuncName top-level function %q exp %q", codeLocation.FuncIdentifier(), expFuncName)
	}

	// anonymous function should work
	codeLocation, err = FuncName(anonymous)
	// FuncName(anonymous func) → name: File: "/opt/sw/parl/preflect/function-name_test.go" Line: 25 FuncName: "github.com/haraldrudell/parl/preflect.TestFunctionName.func1" err: “OK”
	t.Logf("FuncName(anonymous func) → name: %s err: “%s”",
		codeLocation.Dump(), perrors.Short(err),
	)
	if err != nil {
		t.Errorf("FAIL FuncName anonymous function err: %s", perrors.Short(err))
	}
	if !strings.HasPrefix(codeLocation.FuncIdentifier(), expAnonymous) {
		t.Errorf("FAIL FuncName anonymous prefix bad: %q exp %q", codeLocation.FuncIdentifier(), expAnonymous)
	}

	// method should work
	codeLocation, err = FuncName(os.Stdout.Close)
	// FuncName(t.Run method) → name: File: "<autogenerated>" Line: 1 FuncName: "testing.(*T).Run-fm" err: “OK”
	t.Logf("FuncName(t.Run method) → name: %s err: “%s”",
		codeLocation.Dump(), perrors.Short(err),
	)
	if err != nil {
		t.Errorf("FAIL FuncName method err: %s", perrors.Short(err))
	}
	if codeLocation.FuncIdentifier() != expMethod {
		t.Errorf("FAIL FuncName method %q exp %q", codeLocation.FuncIdentifier(), expMethod)
	}

	// funcOrMethod nil should return error
	codeLocation, err = FuncName(nil)
	// FuncName(nil) → name: "" err:
	// “preflect.FuncName funcOrMethod cannot be nil at preflect.FuncName()-function-name.go:20”
	t.Logf("FuncName(nil) → name: %q err: “%s”",
		codeLocation, perrors.Short(err),
	)
	if !errors.Is(err, parl.ErrNil) {
		t.Errorf("FAIL FuncName nil did not return error: actual %q err: %s",
			codeLocation, perrors.Short(err),
		)
	}

	// funcOrMethod not function should return error
	codeLocation, err = FuncName(0)
	// FuncName(0) → name: "" err:
	// “preflect.FuncName funcOrMethod not func: int at preflect.FuncName()-function-name.go:26”
	t.Logf("FuncName(0) → name: %q err: “%s”",
		codeLocation, perrors.Short(err),
	)
	if err == nil {
		t.Errorf("FAIL FuncName(0) did not return error")
	}
}
